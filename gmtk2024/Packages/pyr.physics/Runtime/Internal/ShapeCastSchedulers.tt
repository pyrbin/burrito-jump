<#
    /*THIS IS A T4 FILE - re-run using t4 <file-name> */
#>
<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ output extension=".g.cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Generated by T4 (Mono.TextTemplating) from the file ShapeCastSchedulers.tt
//
#nullable enable
#pragma warning disable CS8618
#pragma warning disable CS8602
#pragma warning disable CS8625

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Linq;
using Cysharp.Threading.Tasks;
using pyr.Shared.Common;
using pyr.Shared.Extensions;
using pyr.Union.Monads;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using Unity.Mathematics;
using UnityEngine;
using static pyr.Union.Global;

namespace pyr.Physics.Internal;

internal class Constants
{
    public const int k_InitialCapacity = 1024;

    public const int k_MaxHits = 24;
}

<#
    foreach(var cmd in commands)
    {
#>
internal class <#= cmd.Command #><#= cmd.GenerateTypes.ToString() #>Scheduler : IDisposable
{
    private NativeList<<#= cmd.Command #>> _Commands = new(Constants.k_InitialCapacity, Allocator.Persistent);
    private NativeArray<<#= cmd.Command #>> _TempCommands;

    private NativeArray<<#= cmd.ResultType #>> _Results;
<#
    if (cmd.GenerateTypes == GenerateTypes.Single)
    {
#>
    private NativeArray<bool> _HasHits;
    private NativeArray<RaycastHit> _NearestHit;
<#
    }
#>
    private List<UniTaskCompletionSource<<#= cmd.ReturnResultType #>>> _Listeners = new(Constants.k_InitialCapacity);
    private UniTaskCompletionSource<<#= cmd.ReturnResultType #>>[]? _ActiveListeners;
    private int _ActiveLength = 0;

    private int Length => _Commands.Length;

    public bool IsCreated { get; private set; } = true;

    public bool HasWork => Length > 0;

    private bool IsRunning = false;

    ~<#= cmd.Command #><#= cmd.GenerateTypes.ToString() #>Scheduler()
    {
        Dispose();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public UniTask<<#= cmd.ReturnResultType #>> Dispatch(<#= cmd.ParameterList #>, QueryParameters? queryParameters = null)
    {
        if (!IsCreated) return new UniTask<<#= cmd.ReturnResultType #>>(default);



        _Commands.Add(new ()
        {
<#
    foreach (var (_, name) in cmd.Parameters)
    {
#>
            <#=$"{name} = {name},"#>
<#
    }
#>
            queryParameters = queryParameters ?? QueryParameters.Default
        });

        var completion = new UniTaskCompletionSource<<#= cmd.ReturnResultType #>>();
        _Listeners.Add(completion);
        return completion.Task;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public JobHandle Schedule(JobHandle deps = default)
    {
        if (Length == 0 || IsRunning || !IsCreated) return deps;

        IsRunning = true;

        _Results = new(Length * Constants.k_MaxHits, Allocator.TempJob);
        _TempCommands = new(Length, Allocator.TempJob);
        _TempCommands.CopyFrom(_Commands.AsArray());

        var commandsPerJob = math.max(Length / JobsUtility.JobWorkerCount, 1);
        var handle = <#= cmd.Command #>.ScheduleBatch(_TempCommands, _Results, commandsPerJob, Constants.k_MaxHits);
<#
        if (cmd.GenerateTypes == GenerateTypes.Single)
        {
#>
        _HasHits = new(Length, Allocator.TempJob);
        _NearestHit = new(Length, Allocator.TempJob);

        Raycast.ResolveNearestHitJob resolveNearestJob = new()
        {
            Results = _Results,
            HasHitResults = _HasHits,
            NearestHitResults = _NearestHit,
            MaxHits = Constants.k_MaxHits
        };

        handle = resolveNearestJob.ScheduleParallel(Length, Constants.k_MaxHits, handle);
<#
        }
#>
        _ActiveLength = Length;
        _ActiveListeners = _Listeners.ToArray();

        _Listeners.Clear();
        _Commands.Clear();

        return handle;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Finish()
    {
        if (!IsRunning) return;

<#
        if (cmd.GenerateTypes == GenerateTypes.Single)
        {
#>
        for (var i = 0; i < _ActiveLength; i++)
        {
#if UNITY_EDITOR
            var cmd = _TempCommands[i];
            Vector3 direction = math.normalizesafe(cmd.direction);
            var distance = math.min(cmd.distance, 10_000);

            DebugDraw.Line(<#= cmd.Origin #>, <#= cmd.Origin #> + direction * distance, Color.yellow);
            var color = _HasHits[i] ? Color.green : Color.red;
#endif
            if (_HasHits[i])
            {
                var hit = _NearestHit[i];
                _ActiveListeners[i].TrySetResult(hit);
#if UNITY_EDITOR
                <#= string.Format(cmd.DrawShape, "+ direction * hit.distance") #>;
#endif
            }
            else
            {
                _ActiveListeners[i].TrySetResult(None);
#if UNITY_EDITOR
                <#= string.Format(cmd.DrawShape, "+ direction * distance") #>;
#endif
            }
        }
<#
        } else {
#>
        for (var i = 0; i < _ActiveLength; i++)
        {
<#
    if (cmd.ResultType == "RaycastHit")
    {
#>
#if UNITY_EDITOR
            var cmd = _TempCommands[i];
            Vector3 direction = math.normalizesafe(cmd.direction);
            var distance = math.min(cmd.distance, 10_000);
            DebugDraw.Line(<#= cmd.Origin #>, <#= cmd.Origin #> + direction * distance, Color.yellow);
#endif
<#
    }
#>
            var start = i * Constants.k_MaxHits;
            var span = _Results.GetSubArray(start, Constants.k_MaxHits);
            var result = span.Where(x => x.HasValidCollider()).ToArray();
            _ActiveListeners[i].TrySetResult(result);
<#
    if (cmd.ResultType == "RaycastHit")
    {
#>
#if UNITY_EDITOR
            var resultArray = result.ToArray();
            if (!resultArray.Any())
            {
                var color = Color.red;
                <#= string.Format(cmd.DrawShape, "+ direction * distance") #>;
            }

            foreach (var hit in resultArray)
            {
                var color = Color.green;
                <#= string.Format(cmd.DrawShape, "+ direction * hit.distance") #>;
            }
#endif
<#
    } else {
#>
#if UNITY_EDITOR
            var cmd = _TempCommands[i];
            var resultArray = result.ToArray();
            var color = result.Any() ? Color.green : Color.red;
            <#= string.Format(cmd.DrawShape, "") #>;
            foreach (var hit in resultArray)
            {
                DebugDraw.Line(<#= cmd.Origin #>, hit.collider.transform.position, Color.green);
            }
#endif
<#
    }
#>
            span.Dispose();
        }
<#
        }
#>

        _Results.Dispose();
        _TempCommands.Dispose();
<#
    if (cmd.GenerateTypes == GenerateTypes.Single)
    {
#>

        _HasHits.Dispose();
        _NearestHit.Dispose();
<#
    }
#>

        IsRunning = false;
    }

    public void Dispose()
    {
        if (!IsCreated) return;

        IsCreated = false;

        if (_Commands.IsCreated) _Commands.Dispose();
        if (_TempCommands.IsCreated) _TempCommands.Dispose();
        if (_Results.IsCreated) _Results.Dispose();

<#
        if (cmd.GenerateTypes == GenerateTypes.Single)
        {
#>
        if (_HasHits.IsCreated) _HasHits.Dispose();
        if (_NearestHit.IsCreated) _NearestHit.Dispose();
<#
        }
#>

        _Listeners.Clear();
    }
}
<#
    }
#>

<#+
    public enum GenerateTypes
    {
        Single,
        All
    }

    public record struct CastCommand
    {
        public string Command { get; set; }
        public string ResultType { get; set; }
        public GenerateTypes GenerateTypes { get; set; }
        public List<(string Type, string Name)> Parameters { get; set; }
        public string DrawShape { get; set; }
        public string Origin { get; set; }

        public string ParameterList => string.Join(", ", Parameters.Select(x => $"{x.Type} {x.Name}"));

        public string ReturnResultType => GenerateTypes switch{

            GenerateTypes.Single => $"Option<{ResultType}>",
            GenerateTypes.All => $"{ResultType}[]",
            _ => throw new ArgumentOutOfRangeException()
        };
    }

    public static CastCommand SpherecastCommand = new()
    {
        Command = "SpherecastCommand",
        ResultType = "RaycastHit",
        GenerateTypes = GenerateTypes.Single,
        Parameters = [
            ("float", "radius"),
            ("in float3", "direction"),
            ("float", "distance"),
            ("in float3", "origin"),
        ],
        Origin = "cmd.origin",
        DrawShape = "DebugDraw.Sphere(cmd.origin {0}, cmd.radius, color)"
    };

    public static CastCommand BoxcastCommand = new()
    {
        Command = "BoxcastCommand",
        ResultType = "RaycastHit",
        GenerateTypes = GenerateTypes.Single,
        Parameters = [
            ("in float3", "center"),
            ("in float3", "halfExtents"),
            ("in float3", "direction"),
            ("float", "distance"),
            ("in quaternion", "orientation"),
        ],
        Origin = "cmd.center",
        DrawShape = "DebugDraw.Box(cmd.center {0}, cmd.halfExtents, cmd.orientation, color)"
    };

    public static CastCommand CapsulecastCommand = new()
    {
        Command = "CapsulecastCommand",
        ResultType = "RaycastHit",
        GenerateTypes = GenerateTypes.Single,
        Parameters = [
            ("in float3", "point1"),
            ("in float3", "point2"),
            ("float", "radius"),
            ("in float3", "direction"),
            ("float", "distance"),
        ],
        Origin = "((cmd.point1 + cmd.point2) * 0.5f)",
        DrawShape = "DebugDraw.Capsule(((cmd.point1 + cmd.point2) * 0.5f) {0}, math.normalize(cmd.point1 - cmd.point2), cmd.radius, math.distance(cmd.point1, cmd.point2), color)"
    };

    public static CastCommand RaycastCommand = new()
    {
        Command = "RaycastCommand",
        ResultType = "RaycastHit",
        GenerateTypes = GenerateTypes.Single,
        Parameters = [
            ("in float3", "from"),
            ("in float3", "direction"),
            ("float", "distance"),
        ],
        Origin = "cmd.from",
        DrawShape = "DebugDraw.Line(cmd.from, cmd.from {0}, color)"
    };

    public static CastCommand OverlapBoxCommand = new()
    {
        Command = "OverlapBoxCommand",
        ResultType = "ColliderHit",
        GenerateTypes = GenerateTypes.All,
        Parameters = [
            ("in float3", "center"),
            ("in float3", "halfExtents"),
            ("quaternion", "orientation"),
        ],
        Origin = "cmd.center",
        DrawShape = "DebugDraw.Box(cmd.center {0}, cmd.halfExtents, cmd.orientation, color)"
    };

    public static CastCommand OverlapSphereCommand = new()
    {
        Command = "OverlapSphereCommand",
        ResultType = "ColliderHit",
        GenerateTypes = GenerateTypes.All,
        Parameters = [
            ("in float3", "point"),
            ("float", "radius"),
        ],
        Origin = "cmd.point",
        DrawShape = "DebugDraw.Sphere(cmd.point {0}, cmd.radius, color)"
    };


    public static CastCommand OverlapCapsuleCommand = new()
    {
        Command = "OverlapCapsuleCommand",
        ResultType = "ColliderHit",
        GenerateTypes = GenerateTypes.All,
        Parameters = [
            ("in float3", "point0"),
            ("in float3", "point1"),
            ("float", "radius"),
        ],
        Origin = "((cmd.point0 + cmd.point1) * 0.5f)",
        DrawShape = "DebugDraw.Capsule(((cmd.point0 + cmd.point1) * 0.5f) {0}, math.normalize(cmd.point0 - cmd.point1), cmd.radius, math.distance(cmd.point0, cmd.point1), color)"
    };


    public static List<CastCommand> commands =
    [
        SpherecastCommand,
        SpherecastCommand with { GenerateTypes = GenerateTypes.All },
        BoxcastCommand,
        BoxcastCommand with { GenerateTypes = GenerateTypes.All },
        CapsulecastCommand,
        CapsulecastCommand with { GenerateTypes = GenerateTypes.All },
        RaycastCommand,
        RaycastCommand with { GenerateTypes = GenerateTypes.All },
        OverlapBoxCommand,
        OverlapSphereCommand,
        OverlapCapsuleCommand
    ];
#>
