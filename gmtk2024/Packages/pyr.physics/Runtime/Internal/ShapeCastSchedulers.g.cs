//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Generated by T4 (Mono.TextTemplating) from the file ShapeCastSchedulers.tt
//
#nullable enable
#pragma warning disable CS8618
#pragma warning disable CS8602
#pragma warning disable CS8625

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Linq;
using Cysharp.Threading.Tasks;
using pyr.Shared.Common;
using pyr.Shared.Extensions;
using pyr.Union.Monads;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using Unity.Mathematics;
using UnityEngine;
using static pyr.Union.Global;

namespace pyr.Physics.Internal;

internal class Constants
{
    public const int k_InitialCapacity = 1024;

    public const int k_MaxHits = 24;
}

internal class SpherecastCommandSingleScheduler : IDisposable
{
    private NativeList<SpherecastCommand> _Commands = new(Constants.k_InitialCapacity, Allocator.Persistent);
    private NativeArray<SpherecastCommand> _TempCommands;

    private NativeArray<RaycastHit> _Results;
    private NativeArray<bool> _HasHits;
    private NativeArray<RaycastHit> _NearestHit;
    private List<UniTaskCompletionSource<Option<RaycastHit>>> _Listeners = new(Constants.k_InitialCapacity);
    private UniTaskCompletionSource<Option<RaycastHit>>[]? _ActiveListeners;
    private int _ActiveLength = 0;

    private int Length => _Commands.Length;

    public bool IsCreated { get; private set; } = true;

    public bool HasWork => Length > 0;

    private bool IsRunning = false;

    ~SpherecastCommandSingleScheduler()
    {
        Dispose();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public UniTask<Option<RaycastHit>> Dispatch(float radius, in float3 direction, float distance, in float3 origin, QueryParameters? queryParameters = null)
    {
        if (!IsCreated) return new UniTask<Option<RaycastHit>>(default);



        _Commands.Add(new ()
        {
            radius = radius,
            direction = direction,
            distance = distance,
            origin = origin,
            queryParameters = queryParameters ?? QueryParameters.Default
        });

        var completion = new UniTaskCompletionSource<Option<RaycastHit>>();
        _Listeners.Add(completion);
        return completion.Task;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public JobHandle Schedule(JobHandle deps = default)
    {
        if (Length == 0 || IsRunning || !IsCreated) return deps;

        IsRunning = true;

        _Results = new(Length * Constants.k_MaxHits, Allocator.TempJob);
        _TempCommands = new(Length, Allocator.TempJob);
        _TempCommands.CopyFrom(_Commands.AsArray());

        var commandsPerJob = math.max(Length / JobsUtility.JobWorkerCount, 1);
        var handle = SpherecastCommand.ScheduleBatch(_TempCommands, _Results, commandsPerJob, Constants.k_MaxHits);
        _HasHits = new(Length, Allocator.TempJob);
        _NearestHit = new(Length, Allocator.TempJob);

        Raycast.ResolveNearestHitJob resolveNearestJob = new()
        {
            Results = _Results,
            HasHitResults = _HasHits,
            NearestHitResults = _NearestHit,
            MaxHits = Constants.k_MaxHits
        };

        handle = resolveNearestJob.ScheduleParallel(Length, Constants.k_MaxHits, handle);
        _ActiveLength = Length;
        _ActiveListeners = _Listeners.ToArray();

        _Listeners.Clear();
        _Commands.Clear();

        return handle;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Finish()
    {
        if (!IsRunning) return;

        for (var i = 0; i < _ActiveLength; i++)
        {
#if UNITY_EDITOR
            var cmd = _TempCommands[i];
            Vector3 direction = math.normalizesafe(cmd.direction);
            var distance = math.min(cmd.distance, 10_000);

            DebugDraw.Line(cmd.origin, cmd.origin + direction * distance, Color.yellow);
            var color = _HasHits[i] ? Color.green : Color.red;
#endif
            if (_HasHits[i])
            {
                var hit = _NearestHit[i];
                _ActiveListeners[i].TrySetResult(hit);
#if UNITY_EDITOR
                DebugDraw.Sphere(cmd.origin + direction * hit.distance, cmd.radius, color);
#endif
            }
            else
            {
                _ActiveListeners[i].TrySetResult(None);
#if UNITY_EDITOR
                DebugDraw.Sphere(cmd.origin + direction * distance, cmd.radius, color);
#endif
            }
        }

        _Results.Dispose();
        _TempCommands.Dispose();

        _HasHits.Dispose();
        _NearestHit.Dispose();

        IsRunning = false;
    }

    public void Dispose()
    {
        if (!IsCreated) return;

        IsCreated = false;

        if (_Commands.IsCreated) _Commands.Dispose();
        if (_TempCommands.IsCreated) _TempCommands.Dispose();
        if (_Results.IsCreated) _Results.Dispose();

        if (_HasHits.IsCreated) _HasHits.Dispose();
        if (_NearestHit.IsCreated) _NearestHit.Dispose();

        _Listeners.Clear();
    }
}
internal class SpherecastCommandAllScheduler : IDisposable
{
    private NativeList<SpherecastCommand> _Commands = new(Constants.k_InitialCapacity, Allocator.Persistent);
    private NativeArray<SpherecastCommand> _TempCommands;

    private NativeArray<RaycastHit> _Results;
    private List<UniTaskCompletionSource<RaycastHit[]>> _Listeners = new(Constants.k_InitialCapacity);
    private UniTaskCompletionSource<RaycastHit[]>[]? _ActiveListeners;
    private int _ActiveLength = 0;

    private int Length => _Commands.Length;

    public bool IsCreated { get; private set; } = true;

    public bool HasWork => Length > 0;

    private bool IsRunning = false;

    ~SpherecastCommandAllScheduler()
    {
        Dispose();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public UniTask<RaycastHit[]> Dispatch(float radius, in float3 direction, float distance, in float3 origin, QueryParameters? queryParameters = null)
    {
        if (!IsCreated) return new UniTask<RaycastHit[]>(default);



        _Commands.Add(new ()
        {
            radius = radius,
            direction = direction,
            distance = distance,
            origin = origin,
            queryParameters = queryParameters ?? QueryParameters.Default
        });

        var completion = new UniTaskCompletionSource<RaycastHit[]>();
        _Listeners.Add(completion);
        return completion.Task;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public JobHandle Schedule(JobHandle deps = default)
    {
        if (Length == 0 || IsRunning || !IsCreated) return deps;

        IsRunning = true;

        _Results = new(Length * Constants.k_MaxHits, Allocator.TempJob);
        _TempCommands = new(Length, Allocator.TempJob);
        _TempCommands.CopyFrom(_Commands.AsArray());

        var commandsPerJob = math.max(Length / JobsUtility.JobWorkerCount, 1);
        var handle = SpherecastCommand.ScheduleBatch(_TempCommands, _Results, commandsPerJob, Constants.k_MaxHits);
        _ActiveLength = Length;
        _ActiveListeners = _Listeners.ToArray();

        _Listeners.Clear();
        _Commands.Clear();

        return handle;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Finish()
    {
        if (!IsRunning) return;

        for (var i = 0; i < _ActiveLength; i++)
        {
#if UNITY_EDITOR
            var cmd = _TempCommands[i];
            Vector3 direction = math.normalizesafe(cmd.direction);
            var distance = math.min(cmd.distance, 10_000);
            DebugDraw.Line(cmd.origin, cmd.origin + direction * distance, Color.yellow);
#endif
            var start = i * Constants.k_MaxHits;
            var span = _Results.GetSubArray(start, Constants.k_MaxHits);
            var result = span.Where(x => x.HasValidCollider()).ToArray();
            _ActiveListeners[i].TrySetResult(result);
#if UNITY_EDITOR
            var resultArray = result.ToArray();
            if (!resultArray.Any())
            {
                var color = Color.red;
                DebugDraw.Sphere(cmd.origin + direction * distance, cmd.radius, color);
            }

            foreach (var hit in resultArray)
            {
                var color = Color.green;
                DebugDraw.Sphere(cmd.origin + direction * hit.distance, cmd.radius, color);
            }
#endif
            span.Dispose();
        }

        _Results.Dispose();
        _TempCommands.Dispose();

        IsRunning = false;
    }

    public void Dispose()
    {
        if (!IsCreated) return;

        IsCreated = false;

        if (_Commands.IsCreated) _Commands.Dispose();
        if (_TempCommands.IsCreated) _TempCommands.Dispose();
        if (_Results.IsCreated) _Results.Dispose();


        _Listeners.Clear();
    }
}
internal class BoxcastCommandSingleScheduler : IDisposable
{
    private NativeList<BoxcastCommand> _Commands = new(Constants.k_InitialCapacity, Allocator.Persistent);
    private NativeArray<BoxcastCommand> _TempCommands;

    private NativeArray<RaycastHit> _Results;
    private NativeArray<bool> _HasHits;
    private NativeArray<RaycastHit> _NearestHit;
    private List<UniTaskCompletionSource<Option<RaycastHit>>> _Listeners = new(Constants.k_InitialCapacity);
    private UniTaskCompletionSource<Option<RaycastHit>>[]? _ActiveListeners;
    private int _ActiveLength = 0;

    private int Length => _Commands.Length;

    public bool IsCreated { get; private set; } = true;

    public bool HasWork => Length > 0;

    private bool IsRunning = false;

    ~BoxcastCommandSingleScheduler()
    {
        Dispose();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public UniTask<Option<RaycastHit>> Dispatch(in float3 center, in float3 halfExtents, in float3 direction, float distance, in quaternion orientation, QueryParameters? queryParameters = null)
    {
        if (!IsCreated) return new UniTask<Option<RaycastHit>>(default);



        _Commands.Add(new ()
        {
            center = center,
            halfExtents = halfExtents,
            direction = direction,
            distance = distance,
            orientation = orientation,
            queryParameters = queryParameters ?? QueryParameters.Default
        });

        var completion = new UniTaskCompletionSource<Option<RaycastHit>>();
        _Listeners.Add(completion);
        return completion.Task;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public JobHandle Schedule(JobHandle deps = default)
    {
        if (Length == 0 || IsRunning || !IsCreated) return deps;

        IsRunning = true;

        _Results = new(Length * Constants.k_MaxHits, Allocator.TempJob);
        _TempCommands = new(Length, Allocator.TempJob);
        _TempCommands.CopyFrom(_Commands.AsArray());

        var commandsPerJob = math.max(Length / JobsUtility.JobWorkerCount, 1);
        var handle = BoxcastCommand.ScheduleBatch(_TempCommands, _Results, commandsPerJob, Constants.k_MaxHits);
        _HasHits = new(Length, Allocator.TempJob);
        _NearestHit = new(Length, Allocator.TempJob);

        Raycast.ResolveNearestHitJob resolveNearestJob = new()
        {
            Results = _Results,
            HasHitResults = _HasHits,
            NearestHitResults = _NearestHit,
            MaxHits = Constants.k_MaxHits
        };

        handle = resolveNearestJob.ScheduleParallel(Length, Constants.k_MaxHits, handle);
        _ActiveLength = Length;
        _ActiveListeners = _Listeners.ToArray();

        _Listeners.Clear();
        _Commands.Clear();

        return handle;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Finish()
    {
        if (!IsRunning) return;

        for (var i = 0; i < _ActiveLength; i++)
        {
#if UNITY_EDITOR
            var cmd = _TempCommands[i];
            Vector3 direction = math.normalizesafe(cmd.direction);
            var distance = math.min(cmd.distance, 10_000);

            DebugDraw.Line(cmd.center, cmd.center + direction * distance, Color.yellow);
            var color = _HasHits[i] ? Color.green : Color.red;
#endif
            if (_HasHits[i])
            {
                var hit = _NearestHit[i];
                _ActiveListeners[i].TrySetResult(hit);
#if UNITY_EDITOR
                DebugDraw.Box(cmd.center + direction * hit.distance, cmd.halfExtents, cmd.orientation, color);
#endif
            }
            else
            {
                _ActiveListeners[i].TrySetResult(None);
#if UNITY_EDITOR
                DebugDraw.Box(cmd.center + direction * distance, cmd.halfExtents, cmd.orientation, color);
#endif
            }
        }

        _Results.Dispose();
        _TempCommands.Dispose();

        _HasHits.Dispose();
        _NearestHit.Dispose();

        IsRunning = false;
    }

    public void Dispose()
    {
        if (!IsCreated) return;

        IsCreated = false;

        if (_Commands.IsCreated) _Commands.Dispose();
        if (_TempCommands.IsCreated) _TempCommands.Dispose();
        if (_Results.IsCreated) _Results.Dispose();

        if (_HasHits.IsCreated) _HasHits.Dispose();
        if (_NearestHit.IsCreated) _NearestHit.Dispose();

        _Listeners.Clear();
    }
}
internal class BoxcastCommandAllScheduler : IDisposable
{
    private NativeList<BoxcastCommand> _Commands = new(Constants.k_InitialCapacity, Allocator.Persistent);
    private NativeArray<BoxcastCommand> _TempCommands;

    private NativeArray<RaycastHit> _Results;
    private List<UniTaskCompletionSource<RaycastHit[]>> _Listeners = new(Constants.k_InitialCapacity);
    private UniTaskCompletionSource<RaycastHit[]>[]? _ActiveListeners;
    private int _ActiveLength = 0;

    private int Length => _Commands.Length;

    public bool IsCreated { get; private set; } = true;

    public bool HasWork => Length > 0;

    private bool IsRunning = false;

    ~BoxcastCommandAllScheduler()
    {
        Dispose();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public UniTask<RaycastHit[]> Dispatch(in float3 center, in float3 halfExtents, in float3 direction, float distance, in quaternion orientation, QueryParameters? queryParameters = null)
    {
        if (!IsCreated) return new UniTask<RaycastHit[]>(default);



        _Commands.Add(new ()
        {
            center = center,
            halfExtents = halfExtents,
            direction = direction,
            distance = distance,
            orientation = orientation,
            queryParameters = queryParameters ?? QueryParameters.Default
        });

        var completion = new UniTaskCompletionSource<RaycastHit[]>();
        _Listeners.Add(completion);
        return completion.Task;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public JobHandle Schedule(JobHandle deps = default)
    {
        if (Length == 0 || IsRunning || !IsCreated) return deps;

        IsRunning = true;

        _Results = new(Length * Constants.k_MaxHits, Allocator.TempJob);
        _TempCommands = new(Length, Allocator.TempJob);
        _TempCommands.CopyFrom(_Commands.AsArray());

        var commandsPerJob = math.max(Length / JobsUtility.JobWorkerCount, 1);
        var handle = BoxcastCommand.ScheduleBatch(_TempCommands, _Results, commandsPerJob, Constants.k_MaxHits);
        _ActiveLength = Length;
        _ActiveListeners = _Listeners.ToArray();

        _Listeners.Clear();
        _Commands.Clear();

        return handle;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Finish()
    {
        if (!IsRunning) return;

        for (var i = 0; i < _ActiveLength; i++)
        {
#if UNITY_EDITOR
            var cmd = _TempCommands[i];
            Vector3 direction = math.normalizesafe(cmd.direction);
            var distance = math.min(cmd.distance, 10_000);
            DebugDraw.Line(cmd.center, cmd.center + direction * distance, Color.yellow);
#endif
            var start = i * Constants.k_MaxHits;
            var span = _Results.GetSubArray(start, Constants.k_MaxHits);
            var result = span.Where(x => x.HasValidCollider()).ToArray();
            _ActiveListeners[i].TrySetResult(result);
#if UNITY_EDITOR
            var resultArray = result.ToArray();
            if (!resultArray.Any())
            {
                var color = Color.red;
                DebugDraw.Box(cmd.center + direction * distance, cmd.halfExtents, cmd.orientation, color);
            }

            foreach (var hit in resultArray)
            {
                var color = Color.green;
                DebugDraw.Box(cmd.center + direction * hit.distance, cmd.halfExtents, cmd.orientation, color);
            }
#endif
            span.Dispose();
        }

        _Results.Dispose();
        _TempCommands.Dispose();

        IsRunning = false;
    }

    public void Dispose()
    {
        if (!IsCreated) return;

        IsCreated = false;

        if (_Commands.IsCreated) _Commands.Dispose();
        if (_TempCommands.IsCreated) _TempCommands.Dispose();
        if (_Results.IsCreated) _Results.Dispose();


        _Listeners.Clear();
    }
}
internal class CapsulecastCommandSingleScheduler : IDisposable
{
    private NativeList<CapsulecastCommand> _Commands = new(Constants.k_InitialCapacity, Allocator.Persistent);
    private NativeArray<CapsulecastCommand> _TempCommands;

    private NativeArray<RaycastHit> _Results;
    private NativeArray<bool> _HasHits;
    private NativeArray<RaycastHit> _NearestHit;
    private List<UniTaskCompletionSource<Option<RaycastHit>>> _Listeners = new(Constants.k_InitialCapacity);
    private UniTaskCompletionSource<Option<RaycastHit>>[]? _ActiveListeners;
    private int _ActiveLength = 0;

    private int Length => _Commands.Length;

    public bool IsCreated { get; private set; } = true;

    public bool HasWork => Length > 0;

    private bool IsRunning = false;

    ~CapsulecastCommandSingleScheduler()
    {
        Dispose();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public UniTask<Option<RaycastHit>> Dispatch(in float3 point1, in float3 point2, float radius, in float3 direction, float distance, QueryParameters? queryParameters = null)
    {
        if (!IsCreated) return new UniTask<Option<RaycastHit>>(default);



        _Commands.Add(new ()
        {
            point1 = point1,
            point2 = point2,
            radius = radius,
            direction = direction,
            distance = distance,
            queryParameters = queryParameters ?? QueryParameters.Default
        });

        var completion = new UniTaskCompletionSource<Option<RaycastHit>>();
        _Listeners.Add(completion);
        return completion.Task;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public JobHandle Schedule(JobHandle deps = default)
    {
        if (Length == 0 || IsRunning || !IsCreated) return deps;

        IsRunning = true;

        _Results = new(Length * Constants.k_MaxHits, Allocator.TempJob);
        _TempCommands = new(Length, Allocator.TempJob);
        _TempCommands.CopyFrom(_Commands.AsArray());

        var commandsPerJob = math.max(Length / JobsUtility.JobWorkerCount, 1);
        var handle = CapsulecastCommand.ScheduleBatch(_TempCommands, _Results, commandsPerJob, Constants.k_MaxHits);
        _HasHits = new(Length, Allocator.TempJob);
        _NearestHit = new(Length, Allocator.TempJob);

        Raycast.ResolveNearestHitJob resolveNearestJob = new()
        {
            Results = _Results,
            HasHitResults = _HasHits,
            NearestHitResults = _NearestHit,
            MaxHits = Constants.k_MaxHits
        };

        handle = resolveNearestJob.ScheduleParallel(Length, Constants.k_MaxHits, handle);
        _ActiveLength = Length;
        _ActiveListeners = _Listeners.ToArray();

        _Listeners.Clear();
        _Commands.Clear();

        return handle;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Finish()
    {
        if (!IsRunning) return;

        for (var i = 0; i < _ActiveLength; i++)
        {
#if UNITY_EDITOR
            var cmd = _TempCommands[i];
            Vector3 direction = math.normalizesafe(cmd.direction);
            var distance = math.min(cmd.distance, 10_000);

            DebugDraw.Line(((cmd.point1 + cmd.point2) * 0.5f), ((cmd.point1 + cmd.point2) * 0.5f) + direction * distance, Color.yellow);
            var color = _HasHits[i] ? Color.green : Color.red;
#endif
            if (_HasHits[i])
            {
                var hit = _NearestHit[i];
                _ActiveListeners[i].TrySetResult(hit);
#if UNITY_EDITOR
                DebugDraw.Capsule(((cmd.point1 + cmd.point2) * 0.5f) + direction * hit.distance, math.normalize(cmd.point1 - cmd.point2), cmd.radius, math.distance(cmd.point1, cmd.point2), color);
#endif
            }
            else
            {
                _ActiveListeners[i].TrySetResult(None);
#if UNITY_EDITOR
                DebugDraw.Capsule(((cmd.point1 + cmd.point2) * 0.5f) + direction * distance, math.normalize(cmd.point1 - cmd.point2), cmd.radius, math.distance(cmd.point1, cmd.point2), color);
#endif
            }
        }

        _Results.Dispose();
        _TempCommands.Dispose();

        _HasHits.Dispose();
        _NearestHit.Dispose();

        IsRunning = false;
    }

    public void Dispose()
    {
        if (!IsCreated) return;

        IsCreated = false;

        if (_Commands.IsCreated) _Commands.Dispose();
        if (_TempCommands.IsCreated) _TempCommands.Dispose();
        if (_Results.IsCreated) _Results.Dispose();

        if (_HasHits.IsCreated) _HasHits.Dispose();
        if (_NearestHit.IsCreated) _NearestHit.Dispose();

        _Listeners.Clear();
    }
}
internal class CapsulecastCommandAllScheduler : IDisposable
{
    private NativeList<CapsulecastCommand> _Commands = new(Constants.k_InitialCapacity, Allocator.Persistent);
    private NativeArray<CapsulecastCommand> _TempCommands;

    private NativeArray<RaycastHit> _Results;
    private List<UniTaskCompletionSource<RaycastHit[]>> _Listeners = new(Constants.k_InitialCapacity);
    private UniTaskCompletionSource<RaycastHit[]>[]? _ActiveListeners;
    private int _ActiveLength = 0;

    private int Length => _Commands.Length;

    public bool IsCreated { get; private set; } = true;

    public bool HasWork => Length > 0;

    private bool IsRunning = false;

    ~CapsulecastCommandAllScheduler()
    {
        Dispose();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public UniTask<RaycastHit[]> Dispatch(in float3 point1, in float3 point2, float radius, in float3 direction, float distance, QueryParameters? queryParameters = null)
    {
        if (!IsCreated) return new UniTask<RaycastHit[]>(default);



        _Commands.Add(new ()
        {
            point1 = point1,
            point2 = point2,
            radius = radius,
            direction = direction,
            distance = distance,
            queryParameters = queryParameters ?? QueryParameters.Default
        });

        var completion = new UniTaskCompletionSource<RaycastHit[]>();
        _Listeners.Add(completion);
        return completion.Task;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public JobHandle Schedule(JobHandle deps = default)
    {
        if (Length == 0 || IsRunning || !IsCreated) return deps;

        IsRunning = true;

        _Results = new(Length * Constants.k_MaxHits, Allocator.TempJob);
        _TempCommands = new(Length, Allocator.TempJob);
        _TempCommands.CopyFrom(_Commands.AsArray());

        var commandsPerJob = math.max(Length / JobsUtility.JobWorkerCount, 1);
        var handle = CapsulecastCommand.ScheduleBatch(_TempCommands, _Results, commandsPerJob, Constants.k_MaxHits);
        _ActiveLength = Length;
        _ActiveListeners = _Listeners.ToArray();

        _Listeners.Clear();
        _Commands.Clear();

        return handle;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Finish()
    {
        if (!IsRunning) return;

        for (var i = 0; i < _ActiveLength; i++)
        {
#if UNITY_EDITOR
            var cmd = _TempCommands[i];
            Vector3 direction = math.normalizesafe(cmd.direction);
            var distance = math.min(cmd.distance, 10_000);
            DebugDraw.Line(((cmd.point1 + cmd.point2) * 0.5f), ((cmd.point1 + cmd.point2) * 0.5f) + direction * distance, Color.yellow);
#endif
            var start = i * Constants.k_MaxHits;
            var span = _Results.GetSubArray(start, Constants.k_MaxHits);
            var result = span.Where(x => x.HasValidCollider()).ToArray();
            _ActiveListeners[i].TrySetResult(result);
#if UNITY_EDITOR
            var resultArray = result.ToArray();
            if (!resultArray.Any())
            {
                var color = Color.red;
                DebugDraw.Capsule(((cmd.point1 + cmd.point2) * 0.5f) + direction * distance, math.normalize(cmd.point1 - cmd.point2), cmd.radius, math.distance(cmd.point1, cmd.point2), color);
            }

            foreach (var hit in resultArray)
            {
                var color = Color.green;
                DebugDraw.Capsule(((cmd.point1 + cmd.point2) * 0.5f) + direction * hit.distance, math.normalize(cmd.point1 - cmd.point2), cmd.radius, math.distance(cmd.point1, cmd.point2), color);
            }
#endif
            span.Dispose();
        }

        _Results.Dispose();
        _TempCommands.Dispose();

        IsRunning = false;
    }

    public void Dispose()
    {
        if (!IsCreated) return;

        IsCreated = false;

        if (_Commands.IsCreated) _Commands.Dispose();
        if (_TempCommands.IsCreated) _TempCommands.Dispose();
        if (_Results.IsCreated) _Results.Dispose();


        _Listeners.Clear();
    }
}
internal class RaycastCommandSingleScheduler : IDisposable
{
    private NativeList<RaycastCommand> _Commands = new(Constants.k_InitialCapacity, Allocator.Persistent);
    private NativeArray<RaycastCommand> _TempCommands;

    private NativeArray<RaycastHit> _Results;
    private NativeArray<bool> _HasHits;
    private NativeArray<RaycastHit> _NearestHit;
    private List<UniTaskCompletionSource<Option<RaycastHit>>> _Listeners = new(Constants.k_InitialCapacity);
    private UniTaskCompletionSource<Option<RaycastHit>>[]? _ActiveListeners;
    private int _ActiveLength = 0;

    private int Length => _Commands.Length;

    public bool IsCreated { get; private set; } = true;

    public bool HasWork => Length > 0;

    private bool IsRunning = false;

    ~RaycastCommandSingleScheduler()
    {
        Dispose();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public UniTask<Option<RaycastHit>> Dispatch(in float3 from, in float3 direction, float distance, QueryParameters? queryParameters = null)
    {
        if (!IsCreated) return new UniTask<Option<RaycastHit>>(default);



        _Commands.Add(new ()
        {
            from = from,
            direction = direction,
            distance = distance,
            queryParameters = queryParameters ?? QueryParameters.Default
        });

        var completion = new UniTaskCompletionSource<Option<RaycastHit>>();
        _Listeners.Add(completion);
        return completion.Task;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public JobHandle Schedule(JobHandle deps = default)
    {
        if (Length == 0 || IsRunning || !IsCreated) return deps;

        IsRunning = true;

        _Results = new(Length * Constants.k_MaxHits, Allocator.TempJob);
        _TempCommands = new(Length, Allocator.TempJob);
        _TempCommands.CopyFrom(_Commands.AsArray());

        var commandsPerJob = math.max(Length / JobsUtility.JobWorkerCount, 1);
        var handle = RaycastCommand.ScheduleBatch(_TempCommands, _Results, commandsPerJob, Constants.k_MaxHits);
        _HasHits = new(Length, Allocator.TempJob);
        _NearestHit = new(Length, Allocator.TempJob);

        Raycast.ResolveNearestHitJob resolveNearestJob = new()
        {
            Results = _Results,
            HasHitResults = _HasHits,
            NearestHitResults = _NearestHit,
            MaxHits = Constants.k_MaxHits
        };

        handle = resolveNearestJob.ScheduleParallel(Length, Constants.k_MaxHits, handle);
        _ActiveLength = Length;
        _ActiveListeners = _Listeners.ToArray();

        _Listeners.Clear();
        _Commands.Clear();

        return handle;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Finish()
    {
        if (!IsRunning) return;

        for (var i = 0; i < _ActiveLength; i++)
        {
#if UNITY_EDITOR
            var cmd = _TempCommands[i];
            Vector3 direction = math.normalizesafe(cmd.direction);
            var distance = math.min(cmd.distance, 10_000);

            DebugDraw.Line(cmd.from, cmd.from + direction * distance, Color.yellow);
            var color = _HasHits[i] ? Color.green : Color.red;
#endif
            if (_HasHits[i])
            {
                var hit = _NearestHit[i];
                _ActiveListeners[i].TrySetResult(hit);
#if UNITY_EDITOR
                DebugDraw.Line(cmd.from, cmd.from + direction * hit.distance, color);
#endif
            }
            else
            {
                _ActiveListeners[i].TrySetResult(None);
#if UNITY_EDITOR
                DebugDraw.Line(cmd.from, cmd.from + direction * distance, color);
#endif
            }
        }

        _Results.Dispose();
        _TempCommands.Dispose();

        _HasHits.Dispose();
        _NearestHit.Dispose();

        IsRunning = false;
    }

    public void Dispose()
    {
        if (!IsCreated) return;

        IsCreated = false;

        if (_Commands.IsCreated) _Commands.Dispose();
        if (_TempCommands.IsCreated) _TempCommands.Dispose();
        if (_Results.IsCreated) _Results.Dispose();

        if (_HasHits.IsCreated) _HasHits.Dispose();
        if (_NearestHit.IsCreated) _NearestHit.Dispose();

        _Listeners.Clear();
    }
}
internal class RaycastCommandAllScheduler : IDisposable
{
    private NativeList<RaycastCommand> _Commands = new(Constants.k_InitialCapacity, Allocator.Persistent);
    private NativeArray<RaycastCommand> _TempCommands;

    private NativeArray<RaycastHit> _Results;
    private List<UniTaskCompletionSource<RaycastHit[]>> _Listeners = new(Constants.k_InitialCapacity);
    private UniTaskCompletionSource<RaycastHit[]>[]? _ActiveListeners;
    private int _ActiveLength = 0;

    private int Length => _Commands.Length;

    public bool IsCreated { get; private set; } = true;

    public bool HasWork => Length > 0;

    private bool IsRunning = false;

    ~RaycastCommandAllScheduler()
    {
        Dispose();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public UniTask<RaycastHit[]> Dispatch(in float3 from, in float3 direction, float distance, QueryParameters? queryParameters = null)
    {
        if (!IsCreated) return new UniTask<RaycastHit[]>(default);



        _Commands.Add(new ()
        {
            from = from,
            direction = direction,
            distance = distance,
            queryParameters = queryParameters ?? QueryParameters.Default
        });

        var completion = new UniTaskCompletionSource<RaycastHit[]>();
        _Listeners.Add(completion);
        return completion.Task;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public JobHandle Schedule(JobHandle deps = default)
    {
        if (Length == 0 || IsRunning || !IsCreated) return deps;

        IsRunning = true;

        _Results = new(Length * Constants.k_MaxHits, Allocator.TempJob);
        _TempCommands = new(Length, Allocator.TempJob);
        _TempCommands.CopyFrom(_Commands.AsArray());

        var commandsPerJob = math.max(Length / JobsUtility.JobWorkerCount, 1);
        var handle = RaycastCommand.ScheduleBatch(_TempCommands, _Results, commandsPerJob, Constants.k_MaxHits);
        _ActiveLength = Length;
        _ActiveListeners = _Listeners.ToArray();

        _Listeners.Clear();
        _Commands.Clear();

        return handle;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Finish()
    {
        if (!IsRunning) return;

        for (var i = 0; i < _ActiveLength; i++)
        {
#if UNITY_EDITOR
            var cmd = _TempCommands[i];
            Vector3 direction = math.normalizesafe(cmd.direction);
            var distance = math.min(cmd.distance, 10_000);
            DebugDraw.Line(cmd.from, cmd.from + direction * distance, Color.yellow);
#endif
            var start = i * Constants.k_MaxHits;
            var span = _Results.GetSubArray(start, Constants.k_MaxHits);
            var result = span.Where(x => x.HasValidCollider()).ToArray();
            _ActiveListeners[i].TrySetResult(result);
#if UNITY_EDITOR
            var resultArray = result.ToArray();
            if (!resultArray.Any())
            {
                var color = Color.red;
                DebugDraw.Line(cmd.from, cmd.from + direction * distance, color);
            }

            foreach (var hit in resultArray)
            {
                var color = Color.green;
                DebugDraw.Line(cmd.from, cmd.from + direction * hit.distance, color);
            }
#endif
            span.Dispose();
        }

        _Results.Dispose();
        _TempCommands.Dispose();

        IsRunning = false;
    }

    public void Dispose()
    {
        if (!IsCreated) return;

        IsCreated = false;

        if (_Commands.IsCreated) _Commands.Dispose();
        if (_TempCommands.IsCreated) _TempCommands.Dispose();
        if (_Results.IsCreated) _Results.Dispose();


        _Listeners.Clear();
    }
}
internal class OverlapBoxCommandAllScheduler : IDisposable
{
    private NativeList<OverlapBoxCommand> _Commands = new(Constants.k_InitialCapacity, Allocator.Persistent);
    private NativeArray<OverlapBoxCommand> _TempCommands;

    private NativeArray<ColliderHit> _Results;
    private List<UniTaskCompletionSource<ColliderHit[]>> _Listeners = new(Constants.k_InitialCapacity);
    private UniTaskCompletionSource<ColliderHit[]>[]? _ActiveListeners;
    private int _ActiveLength = 0;

    private int Length => _Commands.Length;

    public bool IsCreated { get; private set; } = true;

    public bool HasWork => Length > 0;

    private bool IsRunning = false;

    ~OverlapBoxCommandAllScheduler()
    {
        Dispose();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public UniTask<ColliderHit[]> Dispatch(in float3 center, in float3 halfExtents, quaternion orientation, QueryParameters? queryParameters = null)
    {
        if (!IsCreated) return new UniTask<ColliderHit[]>(default);



        _Commands.Add(new ()
        {
            center = center,
            halfExtents = halfExtents,
            orientation = orientation,
            queryParameters = queryParameters ?? QueryParameters.Default
        });

        var completion = new UniTaskCompletionSource<ColliderHit[]>();
        _Listeners.Add(completion);
        return completion.Task;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public JobHandle Schedule(JobHandle deps = default)
    {
        if (Length == 0 || IsRunning || !IsCreated) return deps;

        IsRunning = true;

        _Results = new(Length * Constants.k_MaxHits, Allocator.TempJob);
        _TempCommands = new(Length, Allocator.TempJob);
        _TempCommands.CopyFrom(_Commands.AsArray());

        var commandsPerJob = math.max(Length / JobsUtility.JobWorkerCount, 1);
        var handle = OverlapBoxCommand.ScheduleBatch(_TempCommands, _Results, commandsPerJob, Constants.k_MaxHits);
        _ActiveLength = Length;
        _ActiveListeners = _Listeners.ToArray();

        _Listeners.Clear();
        _Commands.Clear();

        return handle;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Finish()
    {
        if (!IsRunning) return;

        for (var i = 0; i < _ActiveLength; i++)
        {
            var start = i * Constants.k_MaxHits;
            var span = _Results.GetSubArray(start, Constants.k_MaxHits);
            var result = span.Where(x => x.HasValidCollider()).ToArray();
            _ActiveListeners[i].TrySetResult(result);
#if UNITY_EDITOR
            var cmd = _TempCommands[i];
            var resultArray = result.ToArray();
            var color = result.Any() ? Color.green : Color.red;
            DebugDraw.Box(cmd.center , cmd.halfExtents, cmd.orientation, color);
            foreach (var hit in resultArray)
            {
                DebugDraw.Line(cmd.center, hit.collider.transform.position, Color.green);
            }
#endif
            span.Dispose();
        }

        _Results.Dispose();
        _TempCommands.Dispose();

        IsRunning = false;
    }

    public void Dispose()
    {
        if (!IsCreated) return;

        IsCreated = false;

        if (_Commands.IsCreated) _Commands.Dispose();
        if (_TempCommands.IsCreated) _TempCommands.Dispose();
        if (_Results.IsCreated) _Results.Dispose();


        _Listeners.Clear();
    }
}
internal class OverlapSphereCommandAllScheduler : IDisposable
{
    private NativeList<OverlapSphereCommand> _Commands = new(Constants.k_InitialCapacity, Allocator.Persistent);
    private NativeArray<OverlapSphereCommand> _TempCommands;

    private NativeArray<ColliderHit> _Results;
    private List<UniTaskCompletionSource<ColliderHit[]>> _Listeners = new(Constants.k_InitialCapacity);
    private UniTaskCompletionSource<ColliderHit[]>[]? _ActiveListeners;
    private int _ActiveLength = 0;

    private int Length => _Commands.Length;

    public bool IsCreated { get; private set; } = true;

    public bool HasWork => Length > 0;

    private bool IsRunning = false;

    ~OverlapSphereCommandAllScheduler()
    {
        Dispose();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public UniTask<ColliderHit[]> Dispatch(in float3 point, float radius, QueryParameters? queryParameters = null)
    {
        if (!IsCreated) return new UniTask<ColliderHit[]>(default);



        _Commands.Add(new ()
        {
            point = point,
            radius = radius,
            queryParameters = queryParameters ?? QueryParameters.Default
        });

        var completion = new UniTaskCompletionSource<ColliderHit[]>();
        _Listeners.Add(completion);
        return completion.Task;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public JobHandle Schedule(JobHandle deps = default)
    {
        if (Length == 0 || IsRunning || !IsCreated) return deps;

        IsRunning = true;

        _Results = new(Length * Constants.k_MaxHits, Allocator.TempJob);
        _TempCommands = new(Length, Allocator.TempJob);
        _TempCommands.CopyFrom(_Commands.AsArray());

        var commandsPerJob = math.max(Length / JobsUtility.JobWorkerCount, 1);
        var handle = OverlapSphereCommand.ScheduleBatch(_TempCommands, _Results, commandsPerJob, Constants.k_MaxHits);
        _ActiveLength = Length;
        _ActiveListeners = _Listeners.ToArray();

        _Listeners.Clear();
        _Commands.Clear();

        return handle;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Finish()
    {
        if (!IsRunning) return;

        for (var i = 0; i < _ActiveLength; i++)
        {
            var start = i * Constants.k_MaxHits;
            var span = _Results.GetSubArray(start, Constants.k_MaxHits);
            var result = span.Where(x => x.HasValidCollider()).ToArray();
            _ActiveListeners[i].TrySetResult(result);
#if UNITY_EDITOR
            var cmd = _TempCommands[i];
            var resultArray = result.ToArray();
            var color = result.Any() ? Color.green : Color.red;
            DebugDraw.Sphere(cmd.point , cmd.radius, color);
            foreach (var hit in resultArray)
            {
                DebugDraw.Line(cmd.point, hit.collider.transform.position, Color.green);
            }
#endif
            span.Dispose();
        }

        _Results.Dispose();
        _TempCommands.Dispose();

        IsRunning = false;
    }

    public void Dispose()
    {
        if (!IsCreated) return;

        IsCreated = false;

        if (_Commands.IsCreated) _Commands.Dispose();
        if (_TempCommands.IsCreated) _TempCommands.Dispose();
        if (_Results.IsCreated) _Results.Dispose();


        _Listeners.Clear();
    }
}
internal class OverlapCapsuleCommandAllScheduler : IDisposable
{
    private NativeList<OverlapCapsuleCommand> _Commands = new(Constants.k_InitialCapacity, Allocator.Persistent);
    private NativeArray<OverlapCapsuleCommand> _TempCommands;

    private NativeArray<ColliderHit> _Results;
    private List<UniTaskCompletionSource<ColliderHit[]>> _Listeners = new(Constants.k_InitialCapacity);
    private UniTaskCompletionSource<ColliderHit[]>[]? _ActiveListeners;
    private int _ActiveLength = 0;

    private int Length => _Commands.Length;

    public bool IsCreated { get; private set; } = true;

    public bool HasWork => Length > 0;

    private bool IsRunning = false;

    ~OverlapCapsuleCommandAllScheduler()
    {
        Dispose();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public UniTask<ColliderHit[]> Dispatch(in float3 point0, in float3 point1, float radius, QueryParameters? queryParameters = null)
    {
        if (!IsCreated) return new UniTask<ColliderHit[]>(default);



        _Commands.Add(new ()
        {
            point0 = point0,
            point1 = point1,
            radius = radius,
            queryParameters = queryParameters ?? QueryParameters.Default
        });

        var completion = new UniTaskCompletionSource<ColliderHit[]>();
        _Listeners.Add(completion);
        return completion.Task;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public JobHandle Schedule(JobHandle deps = default)
    {
        if (Length == 0 || IsRunning || !IsCreated) return deps;

        IsRunning = true;

        _Results = new(Length * Constants.k_MaxHits, Allocator.TempJob);
        _TempCommands = new(Length, Allocator.TempJob);
        _TempCommands.CopyFrom(_Commands.AsArray());

        var commandsPerJob = math.max(Length / JobsUtility.JobWorkerCount, 1);
        var handle = OverlapCapsuleCommand.ScheduleBatch(_TempCommands, _Results, commandsPerJob, Constants.k_MaxHits);
        _ActiveLength = Length;
        _ActiveListeners = _Listeners.ToArray();

        _Listeners.Clear();
        _Commands.Clear();

        return handle;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Finish()
    {
        if (!IsRunning) return;

        for (var i = 0; i < _ActiveLength; i++)
        {
            var start = i * Constants.k_MaxHits;
            var span = _Results.GetSubArray(start, Constants.k_MaxHits);
            var result = span.Where(x => x.HasValidCollider()).ToArray();
            _ActiveListeners[i].TrySetResult(result);
#if UNITY_EDITOR
            var cmd = _TempCommands[i];
            var resultArray = result.ToArray();
            var color = result.Any() ? Color.green : Color.red;
            DebugDraw.Capsule(((cmd.point0 + cmd.point1) * 0.5f) , math.normalize(cmd.point0 - cmd.point1), cmd.radius, math.distance(cmd.point0, cmd.point1), color);
            foreach (var hit in resultArray)
            {
                DebugDraw.Line(((cmd.point0 + cmd.point1) * 0.5f), hit.collider.transform.position, Color.green);
            }
#endif
            span.Dispose();
        }

        _Results.Dispose();
        _TempCommands.Dispose();

        IsRunning = false;
    }

    public void Dispose()
    {
        if (!IsCreated) return;

        IsCreated = false;

        if (_Commands.IsCreated) _Commands.Dispose();
        if (_TempCommands.IsCreated) _TempCommands.Dispose();
        if (_Results.IsCreated) _Results.Dispose();


        _Listeners.Clear();
    }
}

