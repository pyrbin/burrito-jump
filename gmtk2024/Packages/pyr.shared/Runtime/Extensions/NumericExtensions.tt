<#
    /*THIS IS A T4 FILE - re-run using t4 <file-name> */
#>
<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ output extension=".g.cs" #>
<#@ assembly name="System.Core" #>
<#
            (string FullName, string ShortName)[] types =
            {
                ("System.Int16", "Int16"), // short
                ("System.Int32", "Int32"), // int
                ("System.Int64", "Int64"), // long
                ("i128", "I128"), // i128
                ("System.Byte", "Byte"), // byte
                ("System.UInt16", "UInt16"), // ushort
                ("System.UInt32", "UInt32"), // uint
                ("System.UInt64", "UInt64"), // ulong
                ("u128", "U128"), // u128
                ("System.Single", "Single"), // float
                ("System.Double", "Double"), // double
                ("System.Decimal", "Decimal") // decimal
            };
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Generated by T4 (Mono.TextTemplating) from the file NumericExtensions.tt
//

using System;
using System.Runtime.CompilerServices;
using pyr.Union.Monads;

using static pyr.Union.Global;

namespace pyr.Shared.Extensions;
<#
            foreach (var (type, name) in types)
            {
#>

public static class <#= name #>Extensions
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Option<<#= type #>> CheckedAdd(this <#= type #> a, <#= type #> b)
    {
        try
        {
            checked
            {
                return (<#= type #>)(a + b);
            }
        }
        catch (OverflowException)
        {
            return None;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= type #> SaturatingAdd(this <#= type #> a, <#= type #> b)
    {
        return (<#= type #>)a.CheckedAdd(b).Or(<#= GetSaturatingDefaultValue(type) #>);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= type #> WrappingAdd(this <#= type #> a, <#= type #> b)
    {
        unchecked
        {
            return (<#= type #>)(a + b);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Option<<#= type #>> CheckedSub(this <#= type #> a, <#= type #> b)
    {
        try
        {
            checked
            {
                return (<#= type #>)(a - b);
            }
        }
        catch (OverflowException)
        {
            return None;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= type #> SaturatingSub(this <#= type #> a, <#= type #> b)
    {
        return (<#= type #>)a.CheckedSub(b).Or(<#= GetSaturatingDefaultValue(type) #>);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= type #> WrappingSub(this <#= type #> a, <#= type #> b)
    {
        unchecked
        {
            return (<#= type #>)(a - b);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Option<<#= type #>> CheckedMul(this <#= type #> a, <#= type #> b)
    {
        try
        {
            checked
            {
                return (<#= type #>)(a * b);
            }
        }
        catch (OverflowException)
        {
            return None;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= type #> SaturatingMul(this <#= type #> a, <#= type #> b)
    {
        return (<#= type #>)a.CheckedMul(b).Or(<#= GetSaturatingDefaultValue(type) #>);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= type #> WrappingMul(this <#= type #> a, <#= type #> b)
    {
        unchecked
        {
            return (<#= type #>)(a * b);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Option<<#= type #>> CheckedDiv(this <#= type #> a, <#= type #> b)
    {
        try
        {
            checked
            {
                return (<#= type #>)(a / b);
            }
        }
        catch (OverflowException)
        {
            return None;
        }
        catch (DivideByZeroException)
        {
            return None;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= type #> SaturatingDiv(this <#= type #> a, <#= type #> b)
    {
        return (<#= type #>)a.CheckedDiv(b).Or(<#= GetSaturatingDefaultValue(type) #>);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= type #> WrappingDiv(this <#= type #> a, <#= type #> b)
    {
        unchecked
        {
            return (<#= type #>)(a / b);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Option<<#= type #>> CheckedRem(this <#= type #> a, <#= type #> b)
    {
        try
        {
            checked
            {
                return (<#= type #>)(a % b);
            }
        }
        catch (OverflowException)
        {
            return None;
        }
        catch (DivideByZeroException)
        {
            return None;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= type #> SaturatingRem(this <#= type #> a, <#= type #> b)
    {
        return (<#= type #>)a.CheckedRem(b).Or(<#= GetSaturatingDefaultValue(type) #>);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= type #> WrappingRem(this <#= type #> a, <#= type #> b)
    {
        unchecked
        {
            return (<#= type #>)(a % b);
        }
    }
}
<#
            }
#>

<#+
    private static string GetSaturatingDefaultValue(string type)
    {
        return type switch
        {
            "System.Int16" or "System.Int32" or "System.Int64" or "i128" => type + ".MaxValue",
            "System.Byte" or "System.UInt16" or "System.UInt32" or "System.UInt64" or "u128" => type + ".MaxValue",
            "System.Single" or "System.Double" => "float.PositiveInfinity",
            "System.Decimal" => "decimal.MaxValue",
            _ => throw new ArgumentException("Unknown type: " + type)
            };
    }
#>
